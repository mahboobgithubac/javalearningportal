<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Java 9+ Private Interface Methods — Discussion & Examples</title>
  <style>
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; line-height:1.6; color:#111827; background:#f8fafc; margin:0; padding:20px; }
    .container{ max-width:980px; margin:0 auto; background:#fff; border-radius:10px; box-shadow:0 6px 18px rgba(15,23,42,0.06); padding:28px; }
    h1{ margin:0 0 8px; font-size:28px; }
    p.lead{ color:#374151; margin-top:0 }
    .section{ margin-top:20px; padding-top:18px; border-top:1px solid #eef2f7 }
    pre{ background:#0f1724; color:#e6edf3; padding:16px; border-radius:8px; overflow:auto; font-size:13px }
    code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace }
    .note{ background:#f1f5f9; padding:12px; border-radius:8px; color:#0f1724 }
    .example-title{ margin:10px 0; font-weight:600 }
    footer{ margin-top:26px; color:#6b7280; font-size:13px }
  </style>
</head>
<body>
  <div class="container">
    <h1>Java 9+ — Private Interface Methods (Discussion + Real-time Use Case)</h1>
    <p class="lead">This single HTML contains the earlier conversation consolidated: a short explanation of private methods in interfaces (Java 9+), a simple example, and a real-world use case (Payment Gateway). Code blocks are kept runnable-style for easy copy/paste.</p>

    <div class="section">
      <h2>1. Quick Explanation</h2>
      <p>From <strong>Java 9</strong> onward, interfaces can declare <code>private</code> instance methods and <code>private static</code> methods. These are helper methods usable only inside the same interface (for <code>default</code> and <code>static</code> methods) and help remove code duplication. They cannot be <code>abstract</code>, are not visible to implementors, and cannot be overridden.</p>
      <div class="note">
        <strong>Key points:</strong>
        <ul>
          <li>Purpose: centralize shared logic used by multiple <code>default</code>/<code>static</code> methods.</li>
          <li>Access: only within the interface body.</li>
          <li>Modifiers allowed: <code>private</code> and <code>private static</code>.</li>
          <li>Implementing classes cannot see or override them.</li>
        </ul>
      </div>
    </div>

    <div class="section">
      <h2>2. Simple Interface Example</h2>
      <p class="example-title">A compact example demonstrating private instance and private static methods inside an interface:</p>
      <pre><code>// MyInterface.java
interface MyInterface {

    default void method1() {
        commonLogic();
        System.out.println("Method1 specific logic");
    }

    default void method2() {
        commonLogic();
        System.out.println("Method2 specific logic");
    }

    // Private instance method (Java 9+)
    private void commonLogic() {
        System.out.println("Common logic for default methods");
    }

    // Private static method (Java 9+)
    private static void helperStatic() {
        System.out.println("Helper static method");
    }

    static void staticMethod() {
        helperStatic(); // Can call private static method
        System.out.println("Static method logic");
    }
}

// PrivateMethodDemo.java
public class PrivateMethodDemo implements MyInterface {
    public static void main(String[] args) {
        PrivateMethodDemo obj = new PrivateMethodDemo();
        obj.method1();
        obj.method2();
        MyInterface.staticMethod();
    }
}
</code></pre>
    </div>

    <div class="section">
      <h2>3. Real-World Use Case — Payment Gateway Interface</h2>
      <p>In production systems, multiple <code>default</code> methods implementing different payment flows often repeat validation and logging. Private interface methods let you centralize those helper routines.</p>

      <pre><code>// PaymentService.java
interface PaymentService {

    default void payWithCreditCard(String cardNumber, double amount) {
        validatePayment(amount);
        logTransaction("Credit Card", amount);
        System.out.println("Processing credit card payment: " + cardNumber);
    }

    default void payWithUPI(String upiId, double amount) {
        validatePayment(amount);
        logTransaction("UPI", amount);
        System.out.println("Processing UPI payment: " + upiId);
    }

    default void payWithPayPal(String email, double amount) {
        validatePayment(amount);
        logTransaction("PayPal", amount);
        System.out.println("Processing PayPal payment: " + email);
    }

    // Private instance method for validation
    private void validatePayment(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Invalid payment amount!");
        }
    }

    // Private instance method for logging
    private void logTransaction(String method, double amount) {
        System.out.println("[" + method + "] Payment of ₹" + amount + " initiated...");
    }
}

// PaymentDemo.java
public class PaymentDemo implements PaymentService {
    public static void main(String[] args) {
        PaymentDemo service = new PaymentDemo();
        service.payWithCreditCard("1234-5678-9876-5432", 5000);
        service.payWithUPI("user@upi", 2500);
        service.payWithPayPal("user@example.com", 3000);
    }
}
</code></pre>

      <p class="note"><strong>Why this helps:</strong> avoids duplicating <code>validatePayment()</code> and <code>logTransaction()</code> across each payment method, improving maintainability and readability.</p>
    </div>

    <div class="section">
      <h2>4. Where the JDK Uses It</h2>
      <p>Java's own libraries (the JDK) adopted private interface methods to factor out shared logic inside interfaces. This pattern is used in places where multiple related default/static methods needed to share helper code without exposing it to implementors.</p>
    </div>

    <div class="section">
      <h2>5. Notes & Tips</h2>
      <ul>
        <li>Private interface methods are <em>not</em> inherited; they are strictly internal to the interface.</li>
        <li>Use them when multiple default/static methods share common sub-steps (validation, formatting, logging, pre/post checks).</li>
        <li>Prefer small, focused private helpers to keep interface default methods readable.</li>
      </ul>
    </div>

    <footer>
      <div>Generated: Consolidated Java 9+ private interface methods discussion.</div>
    </footer>
  </div>
</body>
</html>
